/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.storeii.nciproject.model;

/**
 *
 * @author Main
 */

import com.storeii.nciproject.Enums;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.persistence.EntityManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;


@RestController // This means that this class is a Controller and @Rest means we don't need to include @ResponseBody
@RequestMapping(path="/webstoredb") // This means URL's start with /webstoredb (after Application path)
public class OrderController {
    // Here we get the beans called X repository (autogenerated by Spring)
    // that allow us to work with the fields.
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private AddressRepository addressRepository;
    
    @Autowired
    private DriverRepository driverRepository;
    
    @Autowired
    private LocationRepository locationRepository;
    
    
    
    @Autowired
    private OrderItemRepository orderItemRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    
    @Autowired
    private SubOrderItemRepository subOrderItemRepository;
    
    @Autowired
    private SupplierRepository supplierRepository;
    
    @Autowired
    private EntityManager entityManager;
    
    
    // Add new
    @PostMapping(path="/addOrder") // Map ONLY POST Requests
    public String addOrder (
        @RequestParam String orderStatus,      // this should be set to 1 for new orders
        @RequestParam String customer_ID,
        @RequestParam String address_ID,
        @RequestParam String driver_ID,
        @RequestParam String location_ID
        // @RequestParam String OrderItems_ID
    ){
        Order order = new Order();
        
        
        // set fields
        int st = Integer.parseInt(orderStatus);
        int cu = Integer.parseInt(customer_ID);
        int ad = Integer.parseInt(address_ID);
        int dr = Integer.parseInt(driver_ID);
        int lo = Integer.parseInt(location_ID);
        //int oi = Integer.parseInt(OrderItems_ID);
        
        order.setOrderStatus(st);// st);
        order.setCustomer(customerRepository.getById(cu));
        order.setAddress(addressRepository.getById(ad));
        order.setDriver(driverRepository.getById(dr));
        order.setLocation(locationRepository.getById(lo));
        //order.setOrderItems(orderItemsRepository.getById(oi));
        
        
        /***** CREATE ORDER AND SUBORDERS *****
        * create the order items
        * while doing that, compile a list of categories/suppliers
        * iterate through that list creating the sub orders for each supplier
        */
        
        // Create a map for the Suppliers -> SubOrders
        Map <Supplier, SubOrder> suppliers = new HashMap<>();

        
        int productId;     //= 2;
        Product product;   //= productRepository.getById(productId);
        int quantity;      //= 7;
        double unitPrice;  //= 26.32;
        
        
        
                                // Create the OrderItems
                                // NOTE: THIS NEEDS TO LOOP THROUGH THE CART ITEMS
                                // THE BELOW ITEM IS ONLY FOR TESTING

                                System.out.println("adding Order item...");

                                productId     = 3;
                                product       = productRepository.getById(productId);
                                quantity      = 77;
                                unitPrice     = 123.32;
                                
                                OrderItem oItem = new OrderItem(order, product, quantity, unitPrice);
                                orderItemRepository.save(oItem);
        
        
        
        /* ASSOCIATE SUBORDER WITH SUPPLIER
        /*** Now we need to get this item to the relevant Supplier. 
        * To do that, we will create a SubOrder for the Supplier (if it 
        * doesn't already exist) and a SubOrderItem for the item, which
        * will be associated with that SubOrder.
        */
        // Create the SubOrderItems
        System.out.println("adding SubOrderItem...");
        Product   prod     = oItem.getProduct();
        Supplier  supplier = prod.getSupplier();
        SubOrder  subOrder = null;
        
        System.out.println("Product is: " + product.getProductName() + " id:" +product.getId());
        System.out.println("Product supplier is:" + supplier);
        
        /* Add a new SubOrder for supplier if supplier is not yet
         * used or just grab the existing suborder if it exists.
        */
        
        if (!suppliers.containsKey(supplier)) {
            System.out.println("adding new SubOrder...");
            subOrder = new SubOrder(Integer.parseInt(orderStatus), order, supplier);
            System.out.println("New supplier is: " + supplier.getStoreName() + " id: " + supplier.getId());
            suppliers.put(supplier, subOrder);  // add to the hashmap of [suppliers -> suborders]
            
            
            // add to the order's list of suppliers
            // this will be used by delivery drivers
            //order.addSupplier(supplier);
            //System.out.println("");
            System.out.println("supplier: " + supplier);
            System.out.println("order:" +order + " has suppliers:" + order.getSuppliers());
            order.addSupplier(supplier);
        } else {
            subOrder = suppliers.get(supplier);
            System.out.println("Adding to an existing supplier suborder "+ subOrder + " for: " + supplier.getStoreName());
        }
        
        
        // Create the SubOrderItem
        if (subOrder != null) {
            SubOrderItem subItem = new SubOrderItem(subOrder, product, quantity);
            subOrderItemRepository.save(subItem); // Save to make persistent
        } else {
            System.out.println("Error: SubOrder is null, cannot add SubOrderItems");
        }
        
        // SAVE THE NEW ORDER AND FINISH
        orderRepository.save(order);
        return "Saved";
    }
    
    
    
    // find all
    @GetMapping(path="/getOrders")
    public Iterable<Order> getOrders() {
      return orderRepository.findAll();  // This returns a JSON or XML with the users
    }
    
    
    // GET ORDERS BELONGING TO A SPECIFIC DRIVER
    @GetMapping(path="/getOrdersForDriver")
    public List<Order> getOrdersForDriver (
        @RequestParam String driverID
    ){
        Driver driver = driverRepository.findById(Integer.parseInt(driverID)).get(); // .get() is VERY important here as it will return the actual object and not just a reference
        return orderRepository.findByDriver(driver);
    }
    
    
    @GetMapping(path="/deliveries")
    public Iterable<Order> getDeliveries(
        @RequestParam String driverID
    ){
        // get the entity
        Driver driver = entityManager.find(Driver.class, Integer.parseInt(driverID));
        
        return orderRepository.findByDriver(driver);
    }
    
    
    
    
    // GET ORDERS BELONGING TO A SPECIFIC DRIVER THAT ARE READY FOR COLLECTION
    @GetMapping(path="/getOrdersForCollectionByDriver")
    public List<Order> getOrdersForCollectionByDriver (
        @RequestParam String driverID
    ){
        Driver driver = driverRepository.findById(Integer.parseInt(driverID)).get(); // .get() is VERY important here as it will return the actual object and not just a reference
        return orderRepository.findOrdersByDriverAndOrderStatus(driver, 2);
    }
    
    
    
    // MARK A SUBORDER AS READY FOR COLLECTION
    @PostMapping(path="/markOrderAsDelivered")
    public String markOrderAsDelivered(
        @RequestParam String orderID
    ){
       Order order = entityManager.find(Order.class, Integer.parseInt(orderID));
       
       order.setOrderStatus(Enums.OrderStatus.COMPLETE.ordinal());
       
       orderRepository.save(order);
       
       return "";
    }
    
}